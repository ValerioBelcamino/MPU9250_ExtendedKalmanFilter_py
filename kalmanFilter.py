import numpy as np 
import math 

class ExtendedKalmanFilter():
    def __init__(self, x=None, P=None, F_=None, Q=None, H_=None, R=None):
        self.x = x
        self.P = P
        self.F_ = F_
        self.Q = Q
        self.H_ = H_
        self.R = R
        self.H_quat = np.array([[1,0,0,0,0,0,0],
                                [0,1,0,0,0,0,0],
                                [0,0,1,0,0,0,0],
                                [0,0,0,1,0,0,0]])

        # self.P = np.eye(7) * 0.1
        # self.Q = np.eye(7) * 0.0001
        # self.R = np.eye(3) * 0.001

    def normalizeQuat(self, q):
        norm = math.sqrt(q[0]**2 + q[1]**2 + q[2]**2 + q[3]**2)
        return q/norm

    def predict(self, u, deltaT):
        self.x = self.f(self.x, u, deltaT)
        self.F_ = self.F(self.x, u)
        # self.x = np.dot(self.F, self.x)
        # print(self.x)
        self.P = np.dot(np.dot(self.F_, self.P), self.F_.T) + self.Q
        return self.normalizeQuat(self.x)

    def update(self, z):
        # y = z - self.h(self.x[:4])
        y = z - np.dot(self.H_quat, self.x)
        # self.H_ = self.H(self.x[:4])
        self.H_ = self.H_quat

        # y = z - np.dot(self.H_, self.x)
        S = np.dot(np.dot(self.H_, self.P), self.H_.T) + self.R
        K = np.dot(np.dot(self.P, self.H_.T), np.linalg.inv(S))
        # print(self.P)
        self.x = self.x + np.dot(K, y)
        I = np.eye(self.F_.shape[0])
        self.P = np.dot(np.dot(I - np.dot(K, self.H_), self.P), (I - np.dot(K, self.H_)).T) + np.dot(np.dot(K, self.R), K.T)
        return self.normalizeQuat(self.x)
    
    
    def f(self, x, u, deltaT):
        update = np.dot(np.array([[0, -(u[0]-x[4]), -(u[1]-x[5]), -(u[2]-x[6]), 0, 0, 0],
                                [(u[0]-x[4]), 0, (u[2]-x[6]), -(u[1]-x[5]), 0, 0, 0],
                                [(u[1]-x[5]), -(u[2]-x[6]), 0, (u[0]-x[4]), 0, 0, 0],
                                [(u[2]-x[6]), (u[1]-x[5]), -(u[0]-x[4]), 0, 0, 0, 0],
                                [0,0,0,0,0,0,0],
                                [0,0,0,0,0,0,0],
                                [0,0,0,0,0,0,0]]),
                                x)
        self.x = self.x + deltaT*update/2
        return self.x


        
    def F(self, x, u):
        F = np.array([[0, -0.5*(u[0]-x[4]), -0.5*(u[1]-x[5]), -0.5*(u[2]-x[6]), 0.5*x[1], 0.5*x[2], 0.5*x[3]],
                    [0.5*(u[0]-x[4]), 0, 0.5*(u[2]-x[6]), -0.5*(u[1]-x[5]), -0.5*x[0], 0.5*x[3], -0.5*x[2]],
                    [0.5*(u[1]-x[5]), -0.5*(u[2]-x[6]), 0, 0.5*(u[0]-x[4]), -0.5*x[3], -0.5*x[0], 0.5*x[1]],
                    [0.5*(u[2]-x[6]), 0.5*(u[1]-x[5]), -0.5*(u[0]-x[4]), 0, 0.5*x[2], -0.5*x[1], -0.5*x[0]],
                    [0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0]])
        return F



    def h(self, q):
        phi = math.atan2(2*(q[0]*q[1] + q[2]*q[3]),
        (q[0]*q[0] - q[1]*q[1] - q[2]*q[2] + q[3]*q[3]))

        
        theta = -math.asin(2*(q[3]*q[1] - q[0]*q[2]))

        psi = math.atan2(2*(q[2]*q[1] + q[0]*q[3]),
        (q[0]*q[0] + q[1]*q[1] - q[2]*q[2] - q[3]*q[3]))

        return np.array([phi, theta, psi])


    def H(self, q):
        # dTheta_dq0 = (2*q[3]**2*q[1] - 4*q[3]*q[0]*q[2] - 2*q[1]*(q[0]**2 + q[1]**2 + q[2]**2))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dTheta_dq1 = (2*(q[3]**2*q[0] + 2*q[3]*q[1]*q[2] + q[0]*(q[0]**2 + q[1]**2 - q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dTheta_dq2 = (2*(q[3]**3 + 2*q[0]*q[1]*q[2] + q[3]*(q[0]**2 - q[1]**2 + q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dTheta_dq3 = (-2*(2*q[3]*q[0]*q[1] + q[3]**2*q[2] + q[2]*(-q[0]**2 + q[1]**2 + q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)

        dTheta_dq0 = (2*q[0]*(-2*q[0]*q[1] - 2*q[2]*q[3]) + 2*q[1]* (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2)) / ((2*q[0]*q[1] + 2*q[2]*q[3])**2 + (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2))
        dTheta_dq1 = (-2*q[1]*(-2*q[0]*q[1] - 2*q[2]*q[3]) + 2*q[0]* (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2)) / ((2*q[0]*q[1] + 2*q[2]*q[3])**2 + (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2))
        dTheta_dq2 = (-2*q[2]*(-2*q[0]*q[1] - 2*q[2]*q[3]) + 2*q[3]* (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2)) / ((2*q[0]*q[1] + 2*q[2]*q[3])**2 + (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2))
        dTheta_dq3 = (2*q[3]*(-2*q[0]*q[1] - 2*q[2]*q[3]) + 2*q[2]* (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2)) / ((2*q[0]*q[1] + 2*q[2]*q[3])**2 + (q[0]**2 - q[1]**2 - q[2]**2 + q[3]**2))

        # dPhi_dq0 = (2*q[2])/math.sqrt(1 - 4*(q[3]*q[1] - q[0]*q[2])**2)
        # dPhi_dq1 = (-2*q[3])/math.sqrt(1 - 4*(q[3]*q[1] - q[0]*q[2])**2)
        # dPhi_dq2 = (2*q[0])/math.sqrt(1 - 4*(q[3]*q[1] - q[0]*q[2])**2)
        # dPhi_dq3 = (-2*q[1])/math.sqrt(1 - 4*(q[3]*q[1] - q[0]*q[2])**2)

        dPhi_dq0 = (2*q[2])/math.sqrt(1 - (2*q[0]*q[2] - 2*q[1]*q[3])**2)
        dPhi_dq1 = (-2*q[3])/math.sqrt(1 - (2*q[0]*q[2] - 2*q[1]*q[3])**2)
        dPhi_dq2 = (2*q[0])/math.sqrt(1 - (2*q[0]*q[2] - 2*q[1]*q[3])**2)
        dPhi_dq3 = (-2*q[1])/math.sqrt(1 - (2*q[0]*q[2] - 2*q[1]*q[3])**2)

        # dPsi_dq0 = (-2*(q[3]**3 + 2*q[0]*q[1]*q[2] + q[3]*(q[0]**2 - q[1]**2 + q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dPsi_dq1 = (-2*(2*q[3]*q[0]*q[1] + q[3]**2*q[2] + q[2]*(-q[0]**2 + q[1]**2 + q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dPsi_dq2 = (-2*q[3]**2*q[1] + 4*q[3]*q[0]*q[2] + 2*q[1]*(q[0]**2 + q[1]**2 + q[2]**2))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)
        # dPsi_dq3 = (2*(q[3]**2*q[0] + 2*q[3]*q[1]*q[2] + q[0]*(q[0]**2 + q[1]**2 - q[2]**2)))/(q[3]**4 + q[0]**4 + 8*q[3]*q[0]*q[1]*q[2] + 2*q[0]**2*(q[1]**2 - q[2]**2) + 2*q[3]**2*(q[0]**2 - q[1]**2 + q[2]**2) + (q[1]**2 + q[2]**2)**2)

        dPsi_dq0 = (2*q[0]*(-2*q[0]*q[3] - 2*q[1]*q[2]) + 2*q[3]*(q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2)) / ((2*q[0]*q[3] + 2*q[1]*q[2])**2 + (q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2))
        dPsi_dq1 = (2*q[1]*(-2*q[0]*q[3] - 2*q[1]*q[2]) + 2*q[2]*(q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2)) / ((2*q[0]*q[3] + 2*q[1]*q[2])**2 + (q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2))
        dPsi_dq2 = (-2*q[2]*(-2*q[0]*q[3] - 2*q[1]*q[2]) + 2*q[1]*(q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2)) / ((2*q[0]*q[3] + 2*q[1]*q[2])**2 + (q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2))
        dPsi_dq3 = (-2*q[3]*(-2*q[0]*q[3] - 2*q[1]*q[2]) + 2*q[0]*(q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2)) / ((2*q[0]*q[3] + 2*q[1]*q[2])**2 + (q[0]**2 + q[1]**2 - q[2]**2 - q[3]**2))

        return np.array([[dTheta_dq0, dTheta_dq1, dTheta_dq2, dTheta_dq3,0,0,0],
                        [dPhi_dq0, dPhi_dq1, dPhi_dq2, dPhi_dq3,0,0,0], 
                        [dPsi_dq0, dPsi_dq1, dPsi_dq2, dPsi_dq3,0,0,0]])